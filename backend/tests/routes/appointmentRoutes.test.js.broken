import request from 'supertest';
import express from 'express';
import mongoose from 'mongoose';
import appointmentModel from '../../models/appointmentModel.js';
import doctorModel from '../../models/doctorModel.js';
import patientModel from '../../models/patientModel.js';
import userRouter from '../../routes/userRoute.js';
import doctorRouter from '../../routes/doctorRoute.js';
import adminRouter from '../../routes/adminRoute.js';
import jwt from 'jsonwebtoken';

// Mock email service
import { jest } from '@jest/globals';

// Create mock functions
const mockSendAppointmentConfirmationEmail = jest.fn().mockResolvedValue({ success: true });
const mockSendAppointmentCancellationEmail = jest.fn().mockResolvedValue({ success: true });

jest.mock('../../services/emailService.js', () => ({
  sendAppointmentConfirmationEmail: mockSendAppointmentConfirmationEmail,
  sendAppointmentCancellationEmail: mockSendAppointmentCancellationEmail
}));

const app = express();
app.use(express.json());
app.use('/api/user', userRouter);
app.use('/api/doctor', doctorRouter);
app.use('/api/admin', adminRouter);

describe('Appointment Routes Tests', () => {
  let testDoctor;
  let testPatient;
  let testAppointment;
  let userToken;
  let doctorToken;
  let adminToken;

  beforeEach(async () => {
    // Clean up database
    await appointmentModel.deleteMany({});
    await doctorModel.deleteMany({});
    await patientModel.deleteMany({});

    // Create test doctor
    testDoctor = new doctorModel({
      name: 'Dr. Test',
      email: 'doctor@test.com',
      password: 'hashedpassword',
      speciality: 'Cardiology',
      fees: 500,
      type: 'Private',
      available: true,
      slots_booked: {}
    });
    await testDoctor.save();

    // Create test patient
    testPatient = new patientModel({
      name: 'Test Patient',
      email: 'patient@test.com',
      password: 'hashedpassword',
      phone: '1234567890'
    });
    await testPatient.save();

    // Generate tokens
    userToken = jwt.sign({ id: testPatient._id }, process.env.JWT_SECRET || 'test-secret');
    doctorToken = jwt.sign({ id: testDoctor._id }, process.env.JWT_SECRET || 'test-secret');
    adminToken = jwt.sign({ id: 'admin-id' }, process.env.JWT_SECRET || 'test-secret');
  });

  describe('POST /api/user/book-appointment', () => {
    it('should book an appointment successfully', async () => {
      const appointmentData = {
        docId: testDoctor._id.toString(),
        slotDate: '15_12_2024',
        slotTime: '10:00'
      };

      const response = await request(app)
        .post('/api/user/book-appointment')
        .set('token', userToken)
        .send(appointmentData);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.message).toBe('Appointment Booked');

      // Verify appointment was created
      const appointment = await appointmentModel.findOne({
        userId: testPatient._id.toString(),
        docId: testDoctor._id.toString()
      });
      expect(appointment).toBeTruthy();
    });

    it('should reject booking without authentication', async () => {
      const appointmentData = {
        docId: testDoctor._id.toString(),
        slotDate: '15_12_2024',
        slotTime: '10:00'
      };

      const response = await request(app)
        .post('/api/user/book-appointment')
        .send(appointmentData);

      expect(response.status).toBe(401);
    });

    it('should reject booking with invalid token', async () => {
      const appointmentData = {
        docId: testDoctor._id.toString(),
        slotDate: '15_12_2024',
        slotTime: '10:00'
      };

      const response = await request(app)
        .post('/api/user/book-appointment')
        .set('token', 'invalid-token')
        .send(appointmentData);

      expect(response.status).toBe(401);
    });

    it('should reject booking when doctor is not available', async () => {
      testDoctor.available = false;
      await testDoctor.save();

      const appointmentData = {
        docId: testDoctor._id.toString(),
        slotDate: '15_12_2024',
        slotTime: '10:00'
      };

      const response = await request(app)
        .post('/api/user/book-appointment')
        .set('token', userToken)
        .send(appointmentData);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(false);
      expect(response.body.message).toBe('Doctor Not Available');
    });
  });

  describe('GET /api/user/appointments', () => {
    beforeEach(async () => {
      // Create test appointment
      testAppointment = new appointmentModel({
        userId: testPatient._id.toString(),
        docId: testDoctor._id.toString(),
        slotDate: '15_12_2024',
        slotTime: '10:00',
        userData: { name: 'Test Patient' },
        docData: { name: 'Dr. Test' },
        amount: 500,
        date: Date.now(),
        payment: 'pending'
      });
      await testAppointment.save();
    });

    it('should get user appointments successfully', async () => {
      const response = await request(app)
        .get('/api/user/appointments')
        .set('token', userToken);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.appointments).toHaveLength(1);
      expect(response.body.appointments[0].userId).toBe(testPatient._id.toString());
    });

    it('should reject request without authentication', async () => {
      const response = await request(app)
        .get('/api/user/appointments');

      expect(response.status).toBe(401);
    });
  });

  describe('POST /api/user/cancel-appointment', () => {
    beforeEach(async () => {
      // Create test appointment
      testAppointment = new appointmentModel({
        userId: testPatient._id.toString(),
        docId: testDoctor._id.toString(),
        slotDate: '15_12_2024',
        slotTime: '10:00',
        userData: { name: 'Test Patient' },
        docData: { name: 'Dr. Test' },
        amount: 500,
        date: Date.now(),
        payment: 'pending'
      });
      await testAppointment.save();

      // Update doctor's slots_booked
      testDoctor.slots_booked = {
        '15_12_2024': ['10:00']
      };
      await testDoctor.save();
    });

    it('should cancel appointment successfully', async () => {
      const cancelData = {
        appointmentId: testAppointment._id.toString()
      };

      const response = await request(app)
        .post('/api/user/cancel-appointment')
        .set('token', userToken)
        .send(cancelData);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.message).toBe('Appointment Cancelled');

      // Verify appointment was cancelled
      const updatedAppointment = await appointmentModel.findById(testAppointment._id);
      expect(updatedAppointment.cancelled).toBe(true);
    });

    it('should reject cancellation without authentication', async () => {
      const cancelData = {
        appointmentId: testAppointment._id.toString()
      };

      const response = await request(app)
        .post('/api/user/cancel-appointment')
        .send(cancelData);

      expect(response.status).toBe(401);
    });

    it('should reject cancellation for unauthorized user', async () => {
      // Create another patient
      const anotherPatient = new patientModel({
        name: 'Another Patient',
        email: 'another@test.com',
        password: 'hashedpassword',
        phone: '1234567891'
      });
      await anotherPatient.save();

      const anotherUserToken = jwt.sign({ id: anotherPatient._id }, process.env.JWT_SECRET || 'test-secret');

      const cancelData = {
        appointmentId: testAppointment._id.toString()
      };

      const response = await request(app)
        .post('/api/user/cancel-appointment')
        .set('token', anotherUserToken)
        .send(cancelData);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(false);
      expect(response.body.message).toBe('Unauthorized action');
    });
  });

  describe('GET /api/doctor/appointments', () => {
    beforeEach(async () => {
      // Create test appointment
      testAppointment = new appointmentModel({
        userId: testPatient._id.toString(),
        docId: testDoctor._id.toString(),
        slotDate: '15_12_2024',
        slotTime: '10:00',
        userData: { name: 'Test Patient' },
        docData: { name: 'Dr. Test' },
        amount: 500,
        date: Date.now(),
        payment: 'pending'
      });
      await testAppointment.save();
    });

    it('should get doctor appointments successfully', async () => {
      const response = await request(app)
        .get('/api/doctor/appointments')
        .set('token', doctorToken);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.appointments).toHaveLength(1);
      expect(response.body.appointments[0].docId).toBe(testDoctor._id.toString());
    });

    it('should reject request without authentication', async () => {
      const response = await request(app)
        .get('/api/doctor/appointments');

      expect(response.status).toBe(401);
    });
  });

  describe('POST /api/doctor/cancel-appointment', () => {
    beforeEach(async () => {
      // Create test appointment
      testAppointment = new appointmentModel({
        userId: testPatient._id.toString(),
        docId: testDoctor._id.toString(),
        slotDate: '15_12_2024',
        slotTime: '10:00',
        userData: { name: 'Test Patient' },
        docData: { name: 'Dr. Test' },
        amount: 500,
        date: Date.now(),
        payment: 'pending'
      });
      await testAppointment.save();
    });

    it('should cancel appointment successfully', async () => {
      const cancelData = {
        appointmentId: testAppointment._id.toString()
      };

      const response = await request(app)
        .post('/api/doctor/cancel-appointment')
        .set('token', doctorToken)
        .send(cancelData);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.message).toBe('Appointment Cancelled');

      // Verify appointment was cancelled
      const updatedAppointment = await appointmentModel.findById(testAppointment._id);
      expect(updatedAppointment.cancelled).toBe(true);
    });

    it('should reject cancellation without authentication', async () => {
      const cancelData = {
        appointmentId: testAppointment._id.toString()
      };

      const response = await request(app)
        .post('/api/doctor/cancel-appointment')
        .send(cancelData);

      expect(response.status).toBe(401);
    });
  });

  describe('POST /api/doctor/complete-appointment', () => {
    beforeEach(async () => {
      // Create test appointment
      testAppointment = new appointmentModel({
        userId: testPatient._id.toString(),
        docId: testDoctor._id.toString(),
        slotDate: '15_12_2024',
        slotTime: '10:00',
        userData: { name: 'Test Patient' },
        docData: { name: 'Dr. Test' },
        amount: 500,
        date: Date.now(),
        payment: 'pending'
      });
      await testAppointment.save();
    });

    it('should complete appointment successfully', async () => {
      const completeData = {
        appointmentId: testAppointment._id.toString()
      };

      const response = await request(app)
        .post('/api/doctor/complete-appointment')
        .set('token', doctorToken)
        .send(completeData);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.message).toBe('Appointment Completed');

      // Verify appointment was completed
      const updatedAppointment = await appointmentModel.findById(testAppointment._id);
      expect(updatedAppointment.isCompleted).toBe(true);
    });

    it('should reject completion without authentication', async () => {
      const completeData = {
        appointmentId: testAppointment._id.toString()
      };

      const response = await request(app)
        .post('/api/doctor/complete-appointment')
        .send(completeData);

      expect(response.status).toBe(401);
    });
  });

  describe('GET /api/admin/appointments', () => {
    beforeEach(async () => {
      // Create test appointment
      testAppointment = new appointmentModel({
        userId: testPatient._id.toString(),
        docId: testDoctor._id.toString(),
        slotDate: '15_12_2024',
        slotTime: '10:00',
        userData: { name: 'Test Patient' },
        docData: { name: 'Dr. Test' },
        amount: 500,
        date: Date.now(),
        payment: 'pending'
      });
      await testAppointment.save();
    });

    it('should get all appointments for admin', async () => {
      const response = await request(app)
        .get('/api/admin/appointments')
        .set('token', adminToken);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.appointments).toHaveLength(1);
    });

    it('should reject request without authentication', async () => {
      const response = await request(app)
        .get('/api/admin/appointments');

      expect(response.status).toBe(401);
    });
  });

  describe('Error Handling', () => {
    it('should handle invalid appointment ID', async () => {
      const cancelData = {
        appointmentId: 'invalid-id'
      };

      const response = await request(app)
        .post('/api/user/cancel-appointment')
        .set('token', userToken)
        .send(cancelData);

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(false);
      expect(response.body.message).toBeDefined();
    });

    it('should handle missing required fields', async () => {
      const response = await request(app)
        .post('/api/user/book-appointment')
        .set('token', userToken)
        .send({});

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(false);
      expect(response.body.message).toBeDefined();
    });

    it('should handle database connection errors gracefully', async () => {
      // This test would require mocking mongoose connection
      // For now, we'll test that the API returns proper error format
      const response = await request(app)
        .post('/api/user/book-appointment')
        .set('token', userToken)
        .send({
          docId: 'non-existent-id',
          slotDate: '15_12_2024',
          slotTime: '10:00'
        });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(false);
      expect(response.body.message).toBeDefined();
    });
  });
});
